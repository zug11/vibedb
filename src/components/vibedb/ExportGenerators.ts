// ─── Export Generators for VibeDB ────────────────────────

interface Column {
  id: string;
  name: string;
  type: string;
  isForeignKey?: boolean;
  linkedTable?: string;
  linkedColumn?: string;
  constraints?: { type: string; value?: string }[];
}

interface TableNode {
  id: string;
  name: string;
  columns: Column[];
  x: number;
  y: number;
}

export function generateSQL(tables: TableNode[]): string {
  let sql = "-- Generated by VibeDB\n\n";
  tables.forEach(t => {
    sql += `CREATE TABLE ${t.name} (\n`;
    const lines: string[] = [];
    t.columns.forEach(col => {
      let line = `  ${col.name} ${col.type.toUpperCase()}`;
      col.constraints?.forEach(c => {
        if (c.type === "primary") line += " PRIMARY KEY";
        if (c.type === "notNull") line += " NOT NULL";
        if (c.type === "unique") line += " UNIQUE";
        if (c.type === "default" && c.value) line += ` DEFAULT ${c.value}`;
      });
      if (col.isForeignKey && col.linkedTable) {
        line += ` REFERENCES ${col.linkedTable}(${col.linkedColumn || "id"})`;
      }
      lines.push(line);
    });
    sql += lines.join(",\n");
    sql += "\n);\n\n";
  });
  return sql;
}

export function generatePrismaSchema(tables: TableNode[]): string {
  let schema = "// Generated by VibeDB\n\n";
  tables.forEach(table => {
    schema += `model ${table.name} {\n`;
    table.columns.forEach(col => {
      let type = col.type;
      if (type === "varchar" || type === "text") type = "String";
      else if (type === "int") type = "Int";
      else if (type === "uuid") type = "String";
      else if (type === "timestamp") type = "DateTime";
      else if (type === "boolean") type = "Boolean";
      else if (type === "numeric" || type === "decimal" || type === "float") type = "Float";
      else if (type === "jsonb") type = "Json";

      const attrs: string[] = [];
      if (col.constraints?.some(c => c.type === "primary")) attrs.push("@id");
      if (col.constraints?.some(c => c.type === "unique")) attrs.push("@unique");
      if (col.constraints?.some(c => c.type === "default" && c.value)) {
        const def = col.constraints!.find(c => c.type === "default");
        attrs.push(`@default(${def!.value})`);
      }
      if (col.isForeignKey && col.linkedTable) {
        const relationName = `${table.name}To${col.linkedTable}`;
        attrs.push(`@relation("${relationName}", fields: [${col.name}], references: [${col.linkedColumn || "id"}])`);
      }

      schema += `  ${col.name} ${type}${attrs.length ? " " + attrs.join(" ") : ""}\n`;
    });
    schema += "}\n\n";
  });
  return schema;
}

export function generateDrizzleSchema(tables: TableNode[]): string {
  let code =
    "// Generated by VibeDB\nimport { pgTable, serial, varchar, integer, timestamp, boolean, numeric, text, jsonb, uuid, foreignKey } from 'drizzle-orm/pg-core';\n\n";
  tables.forEach(table => {
    code += `export const ${table.name} = pgTable('${table.name}', {\n`;
    table.columns.forEach(col => {
      let type = "varchar";
      if (col.type === "int") type = "integer";
      else if (col.type === "uuid") type = "uuid";
      else if (col.type === "timestamp") type = "timestamp";
      else if (col.type === "boolean") type = "boolean";
      else if (col.type === "numeric") type = "numeric";
      else if (col.type === "text") type = "text";
      else if (col.type === "jsonb") type = "jsonb";

      let chain = `${type}()`;
      if (col.constraints?.some(c => c.type === "primary")) chain += ".primaryKey()";
      if (col.constraints?.some(c => c.type === "unique")) chain += ".unique()";
      if (col.constraints?.some(c => c.type === "notNull")) chain += ".notNull()";
      if (col.constraints?.some(c => c.type === "default")) {
        const def = col.constraints!.find(c => c.type === "default");
        chain += `.default(${def?.value || "''"})`;
      }

      code += `  ${col.name}: ${chain},\n`;
    });
    code += "});\n\n";
  });
  return code;
}

export function generateGraphQLTypes(tables: TableNode[]): string {
  let types = "# Generated by VibeDB\n\ntype Query {\n";
  tables.forEach(t => {
    types += `  ${t.name.toLowerCase()}s: [${t.name}]\n`;
    types += `  ${t.name.toLowerCase()}(id: ID!): ${t.name}\n`;
  });
  types += "}\n\n";

  tables.forEach(table => {
    types += `type ${table.name} {\n`;
    types += "  id: ID!\n";
    table.columns
      .filter(c => !c.constraints?.some(con => con.type === "primary"))
      .forEach(col => {
        let type = "String";
        if (col.type === "int") type = "Int";
        else if (col.type === "boolean") type = "Boolean";
        else if (col.type === "timestamp") type = "DateTime";
        else if (col.type === "numeric" || col.type === "float") type = "Float";

        const nullable = !col.constraints?.some(c => c.type === "notNull") ? "" : "!";
        types += `  ${col.name}: ${type}${nullable}\n`;
      });
    types += "}\n\n";
  });
  return types;
}

export function generateCSV(tables: TableNode[]): string {
  const header = ["Table", "Column", "Type", "Constraints", "Foreign Key"];
  const rows: string[][] = [];

  tables.forEach(table => {
    table.columns.forEach(col => {
      const constraints = col.constraints?.map(c => c.type).join(" | ") || "";
      const fk = col.isForeignKey ? `Ref: ${col.linkedTable}.${col.linkedColumn}` : "";
      rows.push([table.name, col.name, col.type, constraints, fk]);
    });
  });

  return [
    header.join(","),
    ...rows.map(row => row.map(cell => `"${String(cell || "").replace(/"/g, '""')}"`).join(",")),
  ].join("\n");
}
